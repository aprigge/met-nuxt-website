"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.eject = exports.start = exports.build = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const upath_1 = __importDefault(require("upath"));
const options_1 = __importDefault(require("@storybook/vue/dist/cjs/server/options"));
const server_1 = require("@storybook/core/server");
const utils_1 = require("./utils");
const webpack_1 = require("./webpack");
const middlewares_1 = __importDefault(require("./runtime/middlewares"));
function build(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const buildOptions = yield getStorybookConfig(options);
        server_1.buildStatic(buildOptions);
    });
}
exports.build = build;
function start(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const buildOptions = yield getStorybookConfig(options);
        server_1.buildDev(buildOptions);
    });
}
exports.start = start;
function getStorybookConfig(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const { nuxt, nuxtBuilder, nuxtWebpackConfig, nuxtStorybookConfig } = yield buildNuxt(options);
        nuxt.options.serverMiddleware.forEach((m) => {
            if (typeof m === 'string') {
                m = nuxt.resolver.resolvePath(m);
            }
            if (typeof m.handler === 'string') {
                m.handler = nuxt.resolver.resolvePath(m.handler);
            }
            middlewares_1.default.addServerMiddleware(m);
        });
        const userWebpackFinal = nuxtStorybookConfig.webpackFinal;
        nuxtStorybookConfig.webpackFinal = (config, options) => {
            config = webpack_1.getWebpackConfig(config, options);
            if (typeof userWebpackFinal === 'function') {
                config = userWebpackFinal(config, options);
            }
            return config;
        };
        if (!options.staticDir) {
            // Do not register static dir if it does not exists
            // https://github.com/nuxt-community/storybook/issues/263
            const staticDirPath = path_1.default.resolve(nuxt.options.srcDir, nuxt.options.dir.static);
            if (fs_extra_1.default.existsSync(staticDirPath)) {
                options.staticDir = staticDirPath;
            }
        }
        const staticDir = (options.staticDir || '').split(',').map(dir => dir.trim()).filter(Boolean);
        return Object.assign(Object.assign(Object.assign(Object.assign({}, options_1.default), { packageJson: require('../package.json'), versionUpdates: false, rootDir: options.rootDir, configDir: nuxtStorybookConfig.configDir, port: parseInt(process.env.PORT_STORYBOOK || process.env.PORT || nuxtStorybookConfig.port || 3003, 10), nuxt,
            nuxtBuilder,
            nuxtWebpackConfig,
            nuxtStorybookConfig }), options), { staticDir, frameworkPresets: [
                require.resolve('./preset'),
                ...options_1.default.frameworkPresets
            ] });
    });
}
function buildNuxt(options) {
    return __awaiter(this, void 0, void 0, function* () {
        utils_1.ensureCoreJs3(options.rootDir);
        const buildDir = path_1.default.resolve(options.rootDir, '.nuxt-storybook');
        const { loadNuxt, getBuilder } = utils_1.requireMaybeEdge('nuxt');
        const tsConfigPath = path_1.default.resolve(options.tsconfig || options.rootDir, options.tsconfig ? '' : 'tsconfig.json');
        if (fs_extra_1.default.existsSync(tsConfigPath)) {
            const tsNode = utils_1.requireTsNodeOrFail();
            tsNode.register({
                project: tsConfigPath,
                compilerOptions: {
                    module: 'commonjs'
                },
                transpileOnly: true
            });
        }
        // Create new nuxt instance
        const nuxt = yield loadNuxt(Object.assign(Object.assign({}, options), { rootDir: options.rootDir, for: options.mode, configOverrides: {
                ssr: false,
                buildDir,
                build: {
                    corejs: '3',
                    extractCSS: false,
                    // https://github.com/nuxt-community/storybook/issues/102#issuecomment-704821377
                    parallel: false
                },
                buildModules: [
                    '@nuxt/postcss8'
                ]
            }, transpile: [path_1.default.resolve(__dirname, '../storybook')] }));
        /**
         * Filter server-side plugins
         */
        nuxt.options.plugins = nuxt.options.plugins.filter((plugin) => {
            let src = plugin;
            if (typeof plugin === 'object') {
                src = plugin.src;
            }
            if (typeof src === 'string' && src.match(/\.server\.(ts|js)/)) {
                return false;
            }
            return true;
        });
        // Create new builder
        const nuxtBuilder = yield getBuilder(nuxt);
        // Load webpack config for Nuxt
        const { bundleBuilder } = nuxtBuilder;
        const nuxtStorybookConfig = yield nuxtStorybookOptions(nuxt, nuxt.options);
        // Transpile stories
        nuxt.options.build.transpile = [
            ...(nuxt.options.build.transpile || []),
            /.*\.stories\.js$/
        ];
        // generate files
        generateStorybookFiles.call(nuxt.moduleContainer, Object.assign(Object.assign({}, nuxtStorybookConfig), { nuxtOptions: nuxt.options, moduleDir: __dirname }));
        // Mock webpack build as we only need generated templates
        nuxtBuilder.bundleBuilder = {
            build() { }
        };
        yield nuxtBuilder.build();
        // It's important to call getWebpackConfig after bundler build
        const nuxtWebpackConfig = yield bundleBuilder.getWebpackConfig('client');
        // Manually call `webpack:config` hook to extend config by modules
        yield nuxt.callHook('webpack:config', [nuxtWebpackConfig]);
        nuxt.hook('watch:restart', () => {
            nuxt.close();
            buildNuxt(options);
        });
        return {
            nuxt,
            nuxtBuilder,
            nuxtWebpackConfig,
            nuxtStorybookConfig
        };
    });
}
function generateStorybookFiles(options) {
    const templatesRoot = path_1.default.resolve(__dirname, '../storybook');
    this.addTemplate({
        src: path_1.default.resolve(templatesRoot, 'main.js'),
        fileName: path_1.default.join('storybook', 'main.js'),
        options
    });
    this.addTemplate({
        src: path_1.default.resolve(templatesRoot, 'middleware.js'),
        fileName: path_1.default.join('storybook', 'middleware.js'),
        options
    });
    this.addTemplate({
        src: path_1.default.resolve(templatesRoot, 'preview.js'),
        fileName: path_1.default.join('storybook', 'preview.js'),
        options
    });
    this.addTemplate({
        src: path_1.default.resolve(templatesRoot, 'entry.js'),
        fileName: path_1.default.join('storybook', 'entry.js'),
        options
    });
    this.addTemplate({
        src: path_1.default.resolve(templatesRoot, 'nuxt-entry.js'),
        fileName: path_1.default.join('storybook', 'nuxt-entry.js'),
        options
    });
}
function eject(options) {
    const configDir = path_1.default.resolve(options.rootDir, '.storybook');
    const templatesRoot = path_1.default.resolve(__dirname, '../storybook');
    if (!options.force && fs_extra_1.default.existsSync(configDir)) {
        utils_1.logger.warn('Storybook is already ejected, use `--force` to overwrite files.');
        return;
    }
    utils_1.compileTemplate(path_1.default.resolve(templatesRoot, 'eject', 'main.js'), path_1.default.join(configDir, 'main.js'), {});
    utils_1.compileTemplate(path_1.default.resolve(templatesRoot, 'eject', 'middleware.js'), path_1.default.join(configDir, 'middleware.js'), {});
    utils_1.compileTemplate(path_1.default.resolve(templatesRoot, 'eject', 'preview.js'), path_1.default.join(configDir, 'preview.js'), {});
}
exports.eject = eject;
function nuxtStorybookOptions(nuxt, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const nuxtStorybookConfig = Object.assign({
            stories: [],
            addons: [],
            decorators: [],
            parameters: {},
            globalTypes: {},
            modules: true
        }, options.storybook);
        nuxtStorybookConfig.configDir = path_1.default.resolve(options.rootDir, '.storybook');
        if (!fs_extra_1.default.existsSync(nuxtStorybookConfig.configDir)) {
            nuxtStorybookConfig.configDir = path_1.default.resolve(options.rootDir, '.nuxt-storybook', 'storybook');
        }
        let srcDir = options.srcDir || options.rootDir;
        if (!srcDir.startsWith('/')) {
            srcDir = path_1.default.resolve(options.rootDir, srcDir);
        }
        const storiesDir = path_1.default.resolve(srcDir, 'components');
        if (fs_extra_1.default.existsSync(storiesDir)) {
            nuxtStorybookConfig.stories.unshift('~/components/**/*.stories.@(ts|js)');
        }
        // validate decorators
        if (nuxtStorybookConfig.decorators.find(decorator => typeof decorator !== 'string')) {
            utils_1.logger.warn('Decorators inside `nuxt.config` should be simple template strings. Non-string decorators will be ignored.');
            nuxtStorybookConfig.decorators = nuxtStorybookConfig.decorators
                .filter(decorator => typeof decorator === 'string');
        }
        // ensure essential addon exists
        const essentials = nuxtStorybookConfig.addons
            .find(addon => addon === '@storybook/addon-essentials' || addon.name === '@storybook/addon-essentials');
        if (!essentials) {
            nuxtStorybookConfig.addons.unshift('@storybook/addon-essentials');
        }
        if (nuxtStorybookConfig.modules !== false) {
            const { exclude = [] } = nuxtStorybookConfig.modules;
            yield nuxt.callHook('storybook:config', nuxtStorybookConfig);
            nuxtStorybookConfig.stories = nuxtStorybookConfig.stories.filter(story => !exclude.some(e => story.match(e)));
        }
        nuxtStorybookConfig.stories = nuxtStorybookConfig.stories.map(story => upath_1.default.normalize(story
            .replace(/^~~/, path_1.default.relative(nuxtStorybookConfig.configDir, options.rootDir))
            .replace(/^~/, path_1.default.relative(nuxtStorybookConfig.configDir, srcDir))));
        return nuxtStorybookConfig;
    });
}
